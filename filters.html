<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia at Mar 16, 2012 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Async Http Client - Using Filters</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
        <style>body{padding-top: 60px;}</style>
    
      
    <script type="text/javascript" src="./js/apache-maven-fluido.min.js"></script>

    
      <meta name="author" content="Jeanfrancois Arcand" />
    <meta name="Date-Revision-yyyymmdd" content="20120316" />
    <meta http-equiv="Content-Language" content="en" />
    
        </head>
  <body>
      
                        
                    
        <div id="topbar" class="topbar" data-dropdown="dropdown">
      <div class="topbar-inner">
                <div class="container">
                
          <ul>
                        <li class="dropdown" data-dropdown="dropdown" >
        <a href="#" class="dropdown-toggle">User guide</a>
        <ul class="dropdown-menu">
                      <li>      <a href="request.html"  title="Executing request">Executing request</a>
</li>
                      <li>      <a href="configuring.html"  title="Configuring the AsyncHttpClient">Configuring the AsyncHttpClient</a>
</li>
                      <li>      <a href="ssl.html"  title="SSL">SSL</a>
</li>
                      <li>      <a href="filters.html"  title="Using Filters">Using Filters</a>
</li>
                      <li>      <a href="upload.html"  title="Uploading file">Uploading file</a>
</li>
                      <li>      <a href="auth.html"  title="Authentication">Authentication</a>
</li>
                      <li>      <a href="proxy.html"  title="Proxy">Proxy</a>
</li>
                      <li>      <a href="providers.html"  title="Switching Provider">Switching Provider</a>
</li>
                      <li>      <a href="webdav.html"  title="Using the WebDav protocol">Using the WebDav protocol</a>
</li>
                      <li>      <a href="resumable-download.html"  title="Resumable Dowload">Resumable Dowload</a>
</li>
                      <li>      <a href="transfer-listener.html"  title="TransferListener">TransferListener</a>
</li>
                      <li>      <a href="zero-bytes-copy.html"  title="Zero Bytes Copy">Zero Bytes Copy</a>
</li>
                      <li>      <a href="performances.html"  title="Improve raw performance">Improve raw performance</a>
</li>
                      <li>      <a href="oauth.html"  title="OAuth">OAuth</a>
</li>
                  </ul>
      </li>
                <li class="dropdown" data-dropdown="dropdown" >
        <a href="#" class="dropdown-toggle">Project Documentation</a>
        <ul class="dropdown-menu">
                      <li>      <a href="project-info.html"  title="Project Information">Project Information</a>
</li>
                      <li>      <a href="project-reports.html"  title="Project Reports">Project Reports</a>
</li>
                  </ul>
      </li>
                </ul>
          
                        
        
        
        <ul class="nav secondary-nav"><li>
    
    <a href="https://twitter.com/jfarcand" class="twitter-follow-button" data-show-count="true" data-align="right" data-size="large" data-show-screen-name="true" data-lang="en">Follow jfarcand</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

        </li></ul>
                
                  </div>
      </div>
    </div>
    
        <div class="container">
          
      <div id="breadcrumbs">
        <ul class="breadcrumb">
                
                    
                  <li id="publishDate">Last Published: 16 March 2012</li>
                  <li class="divider">|</li> <li id="projectVersion">Version: 1.8.0-SNAPSHOT</li>
                      
                
                    
      
                  </ul>
      </div>

      
      <div id="bodyColumn" class="content">
        <div id="contentBox">
                              
          <div class="section"><h2>Using Filters<a name="Using_Filters"></a></h2><p>The library supports three types of <tt>Filter</tt> who can intercept, transform, decorate and replay transactions: <tt>Request</tt>, <tt>Response</tt> and <tt>IOException</tt>.</p><div class="section"><h3>Request Filter<a name="Request_Filter"></a></h3><p>Request Filters are useful if you need to manipulate the Request or AsyncHandler object before the request is made. As an example, you can throttle requests using the following RequestFilter implementation:</p><div class="source"><pre class="prettyprint">public class ThrottleRequestFilter implements RequestFilter {
    private final int maxConnections;
    private final Semaphore available;
    private final int maxWait;

    public ThrottleRequestFilter(int maxConnections) {
        this.maxConnections = maxConnections;
        this.maxWait = Integer.MAX_VALUE;
        available = new Semaphore(maxConnections, true);
    }

    public ThrottleRequestFilter(int maxConnections, int maxWait) {
        this.maxConnections = maxConnections;
        this.maxWait = maxWait;
        available = new Semaphore(maxConnections, true);
    }

    public FilterContext filter(FilterContext ctx) throws FilterException {
        try {
            if (!available.tryAcquire(maxWait, TimeUnit.MILLISECONDS))
                throw new FilterException(String.format(&quot;No slot available for Request %s with AsyncHandler %s&quot;,
                                                        ctx.getRequest(),
                                                        ctx.getAsyncHandler()));
            }
        } catch (InterruptedException e) {
            throw new FilterException( String.format(&quot;Interrupted Request %s with AsyncHandler %s&quot;,
                                                     ctx.getRequest(),
                                                     ctx.getAsyncHandler()));
        }

        return new FilterContext(new AsyncHandlerWrapper(ctx.getAsyncHandler()), ctx.getRequest());
    }

}

private class AsyncHandlerWrapper implements AsyncHandler&lt;T&gt; {
    private final AsyncHandler asyncHandler;

    public AsyncHandlerWrapper(AsyncHandler asyncHandler) {
        this.asyncHandler = asyncHandler;
    }

    public void onThrowable(Throwable t) {
        asyncHandler.onThrowable(t);
    }

    public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
        return asyncHandler.onBodyPartReceived(bodyPart);
    }

    public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
        return asyncHandler.onStatusReceived(responseStatus);
    }

    public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
        return asyncHandler.onHeadersReceived(headers); }

    public T onCompleted() throws Exception {
        available.release();
        return asyncHandler.onCompleted();
    }
}</pre></div><p>In the above, we decorate the original <tt>AsyncHandler</tt> and use semaphore to throttle requests. To add <tt>RequestFilter</tt>, all you need to do is to configure it on the <tt>AsyncHttpClientConfig</tt>:</p><div class="source"><pre class="prettyprint">AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
b.addRequestFilter(new ThrottleRequestFilter(100));
AsyncHttpClient c = new AsyncHttpClient(b.build());</pre></div><ul><li>Response Filter<p>Like with <tt>Request</tt>, you can also filter the <tt>Response</tt>'s bytes before an <tt>AsyncHandler</tt> gets called. <tt>Response Filters</tt> are always invoked before the library executes the logic for authentication, proxy challenging, redirection etc. That means an application can takes control of those operations at any moment using a <tt>Response Filter</tt>.</p><p>As an example, the following <tt>Response Filter</tt> redirect request from <tt>google.ca</tt> to <tt>google.com</tt> in case <tt>.ca</tt> is not responding:</p><div class="source"><pre class="prettyprint">AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
b.addResponseFilter(new ResponseFilter() {
    public FilterContext filter(FilterContext ctx) throws FilterException {
        if (ctx.getResponseStatus().getStatusCode() == 503) {
            return new FilterContext.FilterContextBuilder(ctx)
                .request(new RequestBuilder(&quot;GET&quot;)
                .setUrl(&quot;http://google.com&quot;).build())
                .build();
        }
    }
});
AsyncHttpClient c = new AsyncHttpClient(b.build());</pre></div></li></ul></div><div class="section"><h3>IOException Filter<a name="IOException_Filter"></a></h3><p>The AsyncHttpClient library support <tt>IOExceptionFilter</tt> that can be used to replay a request in case server a server goes down or unresponsive, a network outage occurs, or nay kind of I/O abnormal situation.</p><p>In those cases, the library will catch the <tt>IOException</tt> and delegate the <tt>IOException</tt> handling to the <tt>Filter</tt>.</p><p>As an example, the following filter will resume an interrupted download instead of restarting downloading the file from the beginning:</p><div class="source"><pre class="prettyprint">AsyncHttpClient c = new AsyncHttpClient(
    new AsyncHttpClientConfig.Builder()
        .addIOExceptionFilter(new ResumableIOExceptionFilter()).build());

Response r = c.prepareGet(&quot;http://host:port/LargeFile.avi&quot;).execute(new AsyncHandler(){...}).get();</pre></div><p>The <tt>IOExceptionFilter</tt> is defined as</p><div class="source"><pre class="prettyprint">public class ResumableIOExceptionFilter implements IOExceptionFilter {
    public FilterContext filter(FilterContext ctx) throws FilterException {
        if (ctx.getIOException() != null ) {
            Request request = new RequestBuilder(ctx.getRequest()).setRangeOffset(file.length());
            return new FilterContext.FilterContextBuilder(ctx)
                .request(request)
                .replayRequest(true)
                .build();
        }
        return ctx;
    }
}</pre></div></div></div><div class="section"><h2>In the above we just catch any <tt>IOException</tt> and replay the request using the <tt>Range</tt> header to tell the remote server to restart sending bytes at that position. This way we don't need to re download the entire file.<a name="In_the_above_we_just_catch_any_IOException_and_replay_the_request_using_the_Range_header_to_tell_the_remote_server_to_restart_sending_bytes_at_that_position._This_way_we_dont_need_to_re_download_the_entire_file."></a></h2></div>
                  </div>
      </div>
    </div>

    <footer class="footer">
            <div class="container">
              <div class="row span16">Copyright &copy;                   2012.
          All Rights Reserved.      
                    
      </div>

        
                <p id="poweredBy" class="pull-right">
                          <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
              </p>
        
                </div>
    </footer>
  </body>
</html>
